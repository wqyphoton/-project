# -project
创新创业实践课作业实现了project1，2，3，4，5，8，9，10，11，14，19，21，22
Project1：implement the naïve birthday attack of reduced SM3
生日攻击的目的是找到一个给定hash值的弱碰撞，其原理来自概率论中的生日悖论：产生hash值碰撞所需的样本数量远小于所有可能hash值的数量。长为n位的hash值共有种可能，产生一次碰撞平均需要次尝试。SM3输出长度256bit，取值空间，计算可知拥有hash值个数达到生日攻击成功的概率接近1
1.#SM3生日攻击  
2.import math  
3.#n为所需hash值个数，d为hash值的取值空间，计算n,d在不同取值下生日攻击成功的概率  
4.def calculate(d,n):  
5.  exponent = (-n * (n - 1)) / (2 * d)  
6.  return 1 - math.e ** exponent;  

这里我尝试对SM3生成hash值的前16bit进行生日攻击。（种可能，需要尝试次）攻击分为离线、在线两个阶段。离线阶段用SM3算法计算hash值（前16bit）生成查找表（个hash值）。在线阶段随机生成一个hash值查表。如果寻找更长bit的碰撞，查表时间也会变长。
本次实现使用Python的SM3模块生成hash值
Project2  implement the Rho method of reduced SM3
ρ攻击的目的也是找一个hash值的弱碰撞，寻找的方式是通过ρ递推表达式来进行多次尝试。这里我尝试对SM3生成hash值的前16bit进行ρ攻击，和生日攻击相同，如果寻找更长bit的碰撞，寻找时间也会变长。本实验选取的ρ函数是计算上一个hash值的hash值作为新的hash值。关键代码如下：
Project3  SM3,SHA-256长度扩展攻击
SM3、SHA-256都是MD结构，MD结构易进行长度扩展攻击。长度扩展攻击的原理是找到一个hash值的弱碰撞，在此基础上对消息长度进行扩展。MD结构每轮输入只与本轮消息分组和上一轮杂凑结果有关，所以在此基础上进行消息扩展得到的hash值仍然会碰撞。实现中先用ρ攻击找到前16bit的碰撞，再将消息进行长度扩展。

project4  优化SM3
一、SM3算法简介
SM3杂凑算法可将长度小于bit的消息 经过填充、反复的消息扩展和压缩，生成长度为256bit的杂凑值。在SＭ3算法中，字表示长度为32的比特串。
1.消息填充

2.布尔函数

3.置换函数

4.消息扩展

5.压缩函数
将256bit中间变量分为8个消息块，初始IV也分为8个消息块，每块32bit

二、SM3优化
1.消息扩展的优化
消息扩展是利用512bit的消息分组 扩展得到68个字，…，和64个字，…，。此步骤可以放在压缩函数里执行，具体实现为：
①在执行6４轮压缩函数前只计算初始的４个字 ，…，
②执行压缩函数时，在压缩函数的第i轮生成， ＝⊕。这样的优化减少了存储，提高了消息扩展的速度。 
2.压缩函数的优化 
①将压缩函数每轮输入的中间变量进行调整：
压缩函数每一轮的最末会执行循环右移： Ａ||Ｂ||Ｃ||Ｄ ← （Ａ||Ｂ||Ｃ||Ｄ） ＞ ＞ ＞32， Ｅ||Ｆ||Ｇ||Ｈ ← （Ｅ||F||Ｇ||Ｈ） ＞ ＞ ＞32。为了减少循环移位产生的赋值运算，可以将字的循环右移改为每轮字块赋值顺序的改变，且这个顺序变动在４轮后还 原，每轮输入如下（以下用F()表示一轮压缩）： 
F（ｉ+０，Ａ，Ｂ，Ｃ，Ｄ，Ｅ，Ｆ，Ｇ，Ｈ，Ｗ） 
F（ｉ+１，Ｄ，Ａ，Ｂ，Ｃ，Ｈ，Ｅ，Ｆ，Ｇ，Ｗ） 
F（ｉ+２，Ｃ，Ｄ，Ａ，Ｂ，Ｇ，Ｈ，Ｅ，Ｆ，Ｗ） 
F（ｉ+３，Ｂ，Ｃ，Ｄ，Ａ，Ｆ，Ｇ，Ｈ，Ｅ，Ｗ） 
②预计算并存储轮常数  ＝ ＜ ＜ ＜ ｉ。减少计算，减少存储空间占用。

Project5  根据RFC6962实现Merkle树
Merkle Tree是存储hash值的树结构。Merkle树的叶子是数据块(例如，文件或者文件的集合)的hash值。非叶节点是其对应子节点串联字符串的hash，如图为一个简单的Merkle树的结构。

在比特币网络中，Merkle树被用来归纳一个区块中的所有交易，同时生成整个交易集合的数字指纹，且提供了一种校验区块是否存在某交易的高效途径。
生成一棵完整的Merkle树需要递归地对Hash节点对进行Hash，并将新生成的hash节点插入到Merkle树中，直到只剩一个Hash节点，该节点就是Merkle 树的根。本次Merkle Tree构建中使用SHA-256，用c++实现
结点结构：
1.class node  
2.{  
3.private:  
4.    string hash_str;//非叶节点存储hash值  
5.    node* parent;  
6.    node* children[2];//两个子结点数据块  
7.public:  
8.    node();//节点初始化  
9.    node* getParent();//得父节点  
10.    void setChildren(node* children_l, node* children_r);//设置子节点  
11.    node* getChildren(int index);//得到子节点  
12.    void setParent(node* parent);//设置父节点  
13.    string getHash();//计算该节点的hash值  
14.    node* getSibling();//得兄弟节点  
15.    void setHash(string hash_str);//计算hash值  
16.    virtual ~node();  
17.};  
18.node::node()  
19.{  
20.    parent = nullptr;  
21.    children[0] = nullptr;  
22.    children[1] = nullptr;  
23.}  
24.void node::setHash(string hash_str)  
25.{  
26.    this->hash_str = sha2::hash256_hex_string(hash_str);  
27.}  
28.node* node::getParent()  
29.{  
30.    return parent;  
31.}  
32.void node::setParent(node* parent)  
33.{  
34.    this->parent = parent;  
35.}  
36.void node::setChildren(node* children_l, node* children_r)  
37.{  
38.    children[0] = children_l;  
39.    children[1] = children_r;  
40.}  
41.node* node::getSibling()  
42.{  
43.    //得到该节点的父节点  
44.    node* parent = getParent();  
45.    //判断父节点的左孩子和本节点是否相同  
46.    //相同返回右孩子，不同返回左孩子  
47.    return parent->getChildren(0) == this ? parent->getChildren(1) : parent->getChildren(0);  
48.}  
49.node* node::getChildren(int index)  
50.{  
51.    return index <= 1 ? children[index] : nullptr;  
52.}  
53.string node::getHash()  
54.{  
55.    return hash_str;  
56.}  
57.node::~node() {}  
树结构：
1.class tree  
2.{  
3.private:  
4.    string merkleRoot;//根结点，存hash值  
5.    int makeBinary(vector<node*>& node_vector);  
6.    void printTreeLevel(vector<node*> v);  
7.    vector<vector<node*>> base; //存节点列表  
8.public:  
9.    tree();//初始化merkle tree  
10.    void buildTree();//创建merkle tree  
11.    void buildBaseLeafes(vector<string> base_leafs);//设置叶子节点  
12.    int verify(string hash);//数据验证  
13.    virtual ~tree();  
14.};  
15.  
16.tree::tree() {}  
17.  
18.int tree::makeBinary(vector<node*>& node_vector) //使叶子节点成为双数  
19.{  
20.    int vectSize = node_vector.size();  
21.    if ((vectSize % 2) != 0) //如果元素个数为奇数，就把再最后一个节点push_back一次  
22.    {  
23.        node_vector.push_back(node_vector.end()[-1]);  
24.        vectSize++;  
25.    }  
26.    return vectSize;  
27.}  
28.  
29.void tree::printTreeLevel(vector<node*> v)  
30.{  
31.    for (node* el : v)  
32.    {  
33.        cout << el->getHash() << endl;  
34.    }  
35.    cout << endl;  
36.}  
37.  
38.void tree::buildTree() //创建merkle tree  
39.{  
40.    do  
41.    {  
42.        vector<node*> new_nodes;  
43.        makeBinary(base.end()[-1]); //传入尾元素 即一个节点列表  
44.  
45.        for (int i = 0; i < base.end()[-1].size(); i += 2)  
46.        {  
47.            node* new_parent = new node; //设置父亲节点 传入最后一个元素 即一个节点列表的第i和i+1个  
48.            base.end()[-1][i]->setParent(new_parent);  
49.            base.end()[-1][i + 1]->setParent(new_parent);  
50.  
51.            //通过两个孩子节点的hash值设置父节点hash值  
52.            new_parent->setHash(base.end()[-1][i]->getHash() + base.end()[-1][i + 1]->getHash());  
53.            //将该父节点的左右孩子节点设置为这两个  
54.            new_parent->setChildren(base.end()[-1][i], base.end()[-1][i + 1]);  
55.            //将new_parent压入new_nodes  
56.            new_nodes.push_back(new_parent);  
57.  
58.            cout << "将 " << base.end()[-1][i]->getHash() << " 和 " << base.end()[-1][i + 1]->getHash() << " 连接,得到对应父节点的哈希值 " << endl;  
59.        }  
60.  
61.        cout << endl;  
62.        cout << "得到的对应父节点的哈希值:" << endl;  
63.        printTreeLevel(new_nodes);  
64.  
65.        base.push_back(new_nodes); //将新一轮的父节点new_nodes压入base  
66.  
67.        cout << "该层的结点有 " << base.end()[-1].size() << " 个:" << endl;  
68.    } while (base.end()[-1].size() > 1); //这样每一轮得到新一层的父节点，知道得到根节点 退出循环  
69.  
70.    merkleRoot = base.end()[-1][0]->getHash(); //根节点的hash值  
71.  
72.    cout << "Merkle Root : " << merkleRoot << endl << endl;  
73.}  
74.  
75.void tree::buildBaseLeafes(vector<string> base_leafs) //建立叶子节点列表  
76.{  
77.    vector<node*> new_nodes;  
78.  
79.    cout << "叶子结点及对应的哈希值: " << endl;  
80.  
81.    for (auto leaf : base_leafs) //给每一个字符串创建对应节点，并通过这个字符串设置hash值  
82.    {  
83.        node* new_node = new node;  
84.        new_node->setHash(leaf);  
85.        cout << leaf << ":" << new_node->getHash() << endl;  
86.  
87.        new_nodes.push_back(new_node);  
88.    }  
89.  
90.    base.push_back(new_nodes);  
91.    cout << endl;  
92.}  
93.  
94.int tree::verify(string hash)  
95.{  
96.    node* el_node = nullptr;  
97.    string act_hash = hash;  
98.  
99.    for (int i = 0; i < base[0].size(); i++)  
100.    {  
101.        if (base[0][i]->getHash() == hash)  
102.        {  
103.            el_node = base[0][i];  
104.        }  
105.    }  
106.    if (el_node == nullptr)  
107.    {  
108.        return 0;  
109.    }  
110.  
111.    cout << "使用到的hash值:" << endl;  
112.    cout << act_hash << endl;  
113.  
114.    do  //验证merkle tree是否改变过   
115.    {  
116.        //父节点的哈希是左孩子的哈希string+右孩子的哈希string  
117.        //如果el_node的父节点的左节点是el_node  
118.        if (el_node->checkDir() == 0)  
119.        {  
120.            //是左孩子就 做孩子的哈希string+右孩子的哈希string  
121.            act_hash = sha2::hash256_hex_string(act_hash + el_node->getSibling()->getHash());  
122.        }  
123.        else  
124.        {  
125.            act_hash = sha2::hash256_hex_string(el_node->getSibling()->getHash() + act_hash);  
126.        }  
127.  
128.        std::cout << act_hash << endl;  
129.  
130.        el_node = el_node->getParent();  
131.    } while ((el_node->getParent()) != NULL); //到达根节点  
132.  
133.    return act_hash == merkleRoot ? 1 : 0;  
134.}  
135.tree::~tree() {}  
Project8  AES实现与ARM
AES在32位处理器上实现原理
为了在ARM上高效实现AES,将其优化为针对32位字的运算。在AES加密算法的实现步骤中,SubBytes与ShifRows占用了大部分运算时间和硬件资源，这两个步骤的顺序可互换。可将SubBytes与MixColumns两个步骤合并成一组。（）表的查询。
一、表的生成方法：
①SubBytes可以表示为一个置换函数,该置换函数包含一个作用在状态字节上的S-盒,用表示
②MixColumns是作用在state各列的函数，可以表示为将经过s-盒替换之后的状态与一个矩阵的乘法。
设轮变换的输入用a表示,经过S-盒的输出用b表示，则:b=(a)
设ShiftRows的输出用c表示，Mixcolumns的输出用d表示,则：



每32位状态,经过4次查表与4次异或,就可以完成4个字节的SubBytes与MixColumns操作，并且每个表都有256个4字节的条目,4个表共占用4 KB的存储空间。另外，最后一-轮的轮函数有没有MixColumns,定义一个表:


二、 Round 函数的实现
加密过程中，每轮的加密流程简化为:ShifRows.T-SubBytes与AddRoundkeys, 这样轮加密过程可以用一个Round函数来描述。在Round函数中，查询T表是实现Round函数关键所在。
128位明文分组表示为一个1x4的状态矩阵 ,状态矩阵中的每个状态是由32位字组成。例如当进行到第j （0 <j < Nr）轮时,状态矩阵2中间状态为,经过不同位数的逻辑移位后取出a[2]中的对应字节,即与送入对应的 （0 ~ 3）表进行替换后,将查询后的4个32位字进行按位异或操作,最后与对应轮密钥按位异或，便得出每轮轮函数所对应的中间状态。Round函数在一次加密过程中需要重复Nr-1次，下图为Round函数的实现流程图。

三、加密密钥扩展的实现
在加密/解密的轮变换中，需要用到轮密钥甲。在密钥扩展中,可以通过查询,表实现。以128位10轮密钥扩展为例,由初始4个32位的字（128位）扩展成为一个包含44个32位字的密钥数组。当扩展到第j （0 <j < Nr）轮密钥时，设此轮的4个32位轮密钥分别为、、、
=[、、、]
=[、、、]
=[、、、]
=[、、、]
根据密钥扩展算法,取,中每个字节，即、、、分别查找,表,其结果重新组成32位的字,然后再与轮常数进行按位异或得到下一轮的轮密钥。=⊕，=⊕，=⊕
下图为表实现32位密钥扩展过程

四、代码实现
修改后的S盒：
1.//字节代换  
2.void SubByte(unsigned char a)//对应te表，只变换一个字节   
3.{  
4.    //S盒  
5.    const unsigned char S_Table[16][16] =  
6.    {  
7.    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,  
8.    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,  
9.    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,  
10.    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,  
11.    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,  
12.    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,  
13.    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,  
14.    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,  
15.    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,  
16.    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,  
17.    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,  
18.    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,  
19.    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,  
20.    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,  
21.    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,  
22.    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16  
23.    };  
24.  
25.            a= S_Table[(int)(a>> 4)][(int)(a& 0x0f)];  
26.}  
 表
1.void te0(unsigned char a )  
2.{  
3.    SubByte(a);  
4.    unsigned char vector;  
5.    vector[0]=0x02*a;  
6.    vector[1]=0x01*a;  
7.    vector[2]=0x01*a;  
8.    vector[3]=0x03*a;  
9.    return vector;  
10. }   
11.   
12.void te1(unsigned char a )  
13.{  
14.    SubByte(vector);  
15.    unsigned char vector;  
16.    vector[0]=0x03*a;  
17.    vector[1]=0x02*a;  
18.    vector[2]=0x01*a;  
19.    vector[3]=0x01*a;  
20.    return vector;  
21. }   
22. void te2(unsigned char a )  
23.{  
24.    SubByte(vector);  
25.    unsigned char vector;  
26.    vector[0]=0x01*a;  
27.    vector[1]=0x03*a;  
28.    vector[2]=0x02*a;  
29.    vector[3]=0x01*a;  
30.    return vector;  
31. }   
32. void te3(unsigned char a )  
33.{  
34.    SubByte(vector);  
35.    unsigned char vector;  
36.    vector[0]=0x01*a;  
37.    vector[1]=0x01*a;  
38.    vector[2]=0x03*a;  
39.    vector[3]=0x02*a;  
40.    return vector;  
41.}  
轮函数：将subbyte和mixcolum合并成查找表
1.void Round(unsigned char state[4][4], unsigned char roundKey[11][4][4], int n)  
2.{  
3.    RowShift(state);  
4.    unsigned char v_state[4][4];//存储中间值   
5.    for(int i=0;i<4;i++)//s盒和列混淆合并为查找te表   
6.    {  
7.        for(int j=0;j<4;j++)//state的每一列分别计算   
8.        {  
9.            a=state[j][i];  
10.        if(j==0)v_state[0]=te0(a);  
11.        if(j==1)v_state[1]=te1(a);  
12.        if(j==2)v_state[2]=te2(a);  
13.        if(j==3)v_state[3]=te3(a);  
14.        }  
15.      
16.            for(int j=0;j<4;j++)  
17.        {  
18.            state[j]=v_state[0]^v_state[1]^v_state[2]^v_state[3];//每一列的异或值   
19.        }  
20.    }  
21.    AddRoundKey(state, roundKey, n);  
22.}  
最后一轮轮函数（没有列混淆）
定义：
1.void te4(unsigned char a )  
2.{  
3.    SubByte(vector);  
4.    unsigned char vector;  
5.    vector[0]=0x01*a;  
6.    vector[1]=0x01*a;  
7.    vector[2]=0x01*a;  
8.    vector[3]=0x01*a;  
9.    return vector;  
10. }   
轮函数：
1.void FinalRound(unsigned char state[4][4], unsigned char roundKey[11][4][4])  
2.{  
3.    RowShift(state);  
4.    unsigned char v_state[4][4];//存储中间值   
5.    for(int i=0;i<4;i++)//s盒和列混淆合并为查找te表   
6.    {  
7.        for(int j=0;j<4;j++)//state的每一列分别计算   
8.        {  
9.            a=state[j][i];  
10.        v_state[0]=te4(a);//最后一轮没有列混淆，只调用te4表即可   
11.        v_state[1]=te4(a);  
12.         v_state[2]=te4(a);  
13.        v_state[3]=te4(a);  
14.        }  
15.      
16.            for(int j=0;j<4;j++)  
17.        {  
18.            state[j]=v_state[0]^v_state[1]^v_state[2]^v_state[3];//每一列的异或值   
19.        }  
20.    }  
21.    AddRoundKey(state, roundKey, 10);  
22.}  

密钥扩展：
_key定义
1.void te4_key(unsigned char a )  
2.  
3.SubByte_Key(vector);  
4.unsigned char vector;  
5.vector[0]=0x01*a;  
6.vector[1]=0x01*a;  
7.vector[2]=0x01*a;  
8.vector[3]=0x01*a;  
9.return vector;  
10.}   
密钥扩展：
1.void KeyExpansion(char key[], unsigned char roundKey[11][4][4])  
2.{  
3.    ProduceState(key, roundKey[0]);  
4.    //用于密钥扩展的轮常数   
5.    const unsigned char Rcon[11] = {0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36 };  
6.    unsigned char vector[4]={0x00,0x00,0x00,0x00};//存储中间值   
7.    for(int i=1;i<11;i++)  
8.    {  
9.        for(int j=0;j<4;j++)   
10.        {  
11.        a=roundkey[i][j][4];  
12.        vector[j]=te4(a);  
13.        }  
14.        roundKey[i][][0]=roundKey[i-1][][0]^vector^Rcon;  
15.        roundKey[i][][1]=roundKey[i-1][][1]^roundKey[i][][0];  
16.        roundKey[i][][2]=roundKey[i-1][][2]^roundKey[i][][1];  
17.        roundKey[i][][3]=roundKey[i-1][][3]^roundKey[i][][2];  
18.    }  
19.}  

project9  AES,SM4实现
一、AES实现
算法描述：
AES分组长度为128位，每个分组为16个字节，每个字节8位。密钥的长度可以使用128位、192位或者258位。密钥的长度不同，加密轮数也不同 AES-128加密轮数为10轮，AES-192为12轮，AES-256为14轮。
以AES-128为例，一轮加密4个操作：字节代换（S盒）、行位移、列混合、轮密钥加
字节代换：查表操作，AES定义了有限域GF()上的S盒。是唯一的非线性变换
行位移：将每一轮中4*4字节的状态第一行不变，第二行左移一位，第三行左移两位，第四行左移三位
列混合：通过矩阵相乘来实现的，经过移位后的状态矩阵与固定的矩阵相乘，得到混淆后的状态矩阵。
轮密钥加：将128位轮密钥key同状态矩阵中的数据进行逐位异或操作。
二、SM4实现代码
SM4 分组长度为 128bit，密钥长度也为 128bit。加密算法与密钥扩展算法均采用 32 轮非线性迭代结构，以字（32 位）为单位进行加密运算，每一次迭代运算均为一轮变换函数F。SM4 算法加/解密算法的结构相同，只是使用轮密钥相反，其中解密轮密钥是加密轮密钥的逆序。
设输入的明文为四个字(X0，X1，X2, X3)，共128 位。输入轮密钥为,i=0,1,…，31，一共 32 个字。输出密文为四个字(Y0，Y1，Y2, Y3)，128 位。
每一轮加密流程可以简单概括为：①、、相互异或，然后与密钥进行异或;②将32bit拆分为4个8bit的长度，放进S盒中进行变换，再组合为32bit的数据；③将32bit依次进行左移2、10、0、18、24位并异或;④异或得到的32bit数据再与进行异或，得出;⑤迭代32次上述操作，将得到的进行反序变换，得出对明文的密文。
加密算法描述如下：










密钥扩展算法：
密钥的扩展算法当中有常数 FK、固定参数 CK 
密钥扩展当中使用的常数FK为以下几个：
FK0=(A3B1BAC6)FK1=(56AA3350),FK2=(677D9197), FK3=(B27022DC)。
固定参数 CK(十六进制) :
00070e15， 1c232a31， 383f64d， 545b6269，
70777e85， 8c939aa1， a8afb6bd， c4cbd2d9，
e0e7eef5， fc030a11， 181f262d， 343b4249，
50575e65， 6c737a81， 888f969d， a4abb2b9，
c0c7ced5， dce3eafl， f8ff060d， 141b2229，
30373e45， 4c535a61， 686f767d， 848b9299，
a0a7aeb5， bcc3cad1， d8dfe6ed， f4fb0209，
10171e25， 2c333a41， 484f565d， 646b7279。



密钥扩展算法采用了非线性变换 T，这使密钥扩展的安全性大大增强。
SM4 的解密算法
SM4解密算法结构和加密算法的结构一样，但轮密钥的使用顺序与加密相反。设输入的密文为(X0，X1，X2, X3)，则输入轮密钥为,i=31,30,…，1，0，输出的明文为(Y0，Y1，Y2, Y3)。
project10  ECDSA实现
一、ECDSA介绍
ECDSA是一个基于椭圆曲线的签名算法。对某个消息进行签名的目的是使接收者确认该消息是由签名者发送的，且未经过篡改。
ECDSA签名生成算法
接收的外部输入是被签名的消息的哈希 z 和签名者的私钥 da，输出是r和s。sign (z,da) = (r, s)
ECDSA签名验证算法
外部输入是 z、s 和签名者的公钥 Ha，输出是 o。verifySign (z, s, Ha) = o如果 o==r，则该签名是有效的，且签名的消息没有被修改
★椭圆曲线上的加法运算：


★ECDSA具体描述：

Project11使用RFC6979实现SM2
SM2是基于椭圆曲线上的离散对数问题的非对称加密算法。
1.椭圆曲线密码算法描述：
上的椭圆曲线E：
①密钥生成：明文空间：P=E  密文空间：C=E×E。设椭圆曲线中有n个点,生成元为α。随机选取x∈。计算y=xα。私钥：x 公钥y
②加密：明文m=(x,y), 随机选取k∈。计算=kα,=ky+m
③解密：m=-x
SM2算法选取参数：

project14使用SM2实现PGP方案
一、PGP介绍
PGP（Pretty Good Privacy）加密由一系列散列、数据压缩、对称密钥加密，以及公钥加密的算法组合而成，每个步骤支持几种算法。
PGP支持消息认证和完整性检测：
①完整性检测被用来检查消息在传输过程中是否被篡改
②消息认证则是确定消息是否确由某特定的人或实体发出。
在PGP中，这些功能默认是和消息加密同时开启的，且同样可以被应用到明文的验证。发送者只需使用PGP为消息创建一个数字签名，即以数据或信息创建一个散列，然后使用发送者的私钥利用散列生成数字签名。
二、SM2实现PGP方案
假设在一个数据M 传输的过程中，发送者为A、接受者为B ，公私钥对(pk,rk)，用SM2、SM3、SM4构建一个同样具有机密性和认证服务的PGP方案：

三、SM2数字签名方案描述
为了兼容PGP方案hash函数使用SM3


Project19  forge a signature
数字签名伪造攻击的攻击手段：
①对消息hash值进行碰撞攻击
若没有hash函数或碰撞攻击能成功则签名伪造能够成功
②尝试获取签名私钥
若能够获取k则可计算私钥（k泄露）
若能获取两个使用同一密钥的签名，使用同一k生成，则可计算出签名私钥（k重用）
若能获取两个使用不同密钥生成的签名，使用同一k生成，则可计算出两个签名私钥
Project21 schnorr batch
1.Schnorr 签名介绍
Schnorr 签名是由 Schnorr 签名算法产生的数字签名。其安全性基于某些离散对数问题的难处理性。Schnorr 的原理描述如下：

2. 聚合签名
聚合签名是使用 Schnorr 签名的各方生成的对各自密钥的签名聚合，它可以把一笔多签交易的各个参与方的公钥和签名合并为一个公钥与签名，整个合并过程是不可见的，无法从合并后的公钥与签名推导出合并前的信息，并且在验证时仅需一次验证即可。
对于上述多重签名的情况，使用 Schnorr 签名算法进行聚合签名，可以提供如下额外的好处：
性能方面：可以大大减少验证签名的成本。Schonrr 签名算法的优势是显而易见的，对于一笔多签交易，原本需要进行多次的验证，而聚合签名仅需验证一次，从而提升节点对于交易的验证速度
交易体积：由于将多个签名聚合为一个签名，可以大大减少多重签名的大小，并且可以显著降低对于网络传输消耗的带宽，以及对于节点存储空间的占用
隐私：使用 Schnorr 聚合签名可以提高链上数据的隐私性。对于验证者来讲，聚合签名看起来和普通的 Schnorr 签名并无区别，无法分辨这一笔交易是普通的交易还是一笔多签交易，而参与交易的用户的公钥和签名都不会暴露出来
一个基于 Schnorr 聚合签名的多签方案：





project22MPT研究报告
Merkle Patricia Tree（MPT）是一种经过改良的、融合了Merkle Tree和前缀树两种树结构优点的数据结构，是以太坊中用来组织管理账户数据、生成交易集合哈希的数据结构。
一、MPT的作用：
①存储任意长度的键值对数据
②提供了一种快速计算所维护数据集哈希标识的机制
③提供了快速状态回滚的机制
④提供了一种称为Merkle证明的证明方法，进行轻节点的扩展，实现简单支付验证
二、相关数据结构介绍
（1）前缀树
前缀树（又称字典树），用于保存关联数组，其键（key）的内容通常为字符串。前缀树节点在树中的位置是由其键的内容所决定的。
优势:使用前缀树来进行查询拥有共同前缀key的数据时十分高效，例如在字典中查找前缀为pre的单词，对于哈希表来说，需要遍历整个表，时间效率为O(n)；然而对于前缀树来说，只需要在树中找到前缀为pre的节点，且遍历以这个节点为根节点的子树即可。但是对于最差的情况（前缀为空串），时间效率为O(n)，仍然需要遍历整棵树，此时效率与哈希表相同。相比于哈希表，在前缀树不会存在哈希冲突的问题。
劣势：直接查找效率低下前缀树的查找效率是O(m)，m为所查找节点的key长度，而哈希表的查找效率为O(1)。且一次查找会有m次IO开销，相比于直接查找，无论是速率、还是对磁盘的压力都比较大。可能会造成空间浪费当存在一个节点，其key值内容很长（如一串很长的字符串），当树中没有与他相同前缀的分支时，为了存储该节点，需要创建许多非叶子节点来构建根节点到该节点间的路径，造成了存储空间的浪费。
（2）Merkle树的特点
在比特币网络中，Merkle树被用来归纳一个区块中的所有交易，同时生成整个交易集合的数字指纹
Merkle树特点
Merkle树叶子节点的value是数据项的内容，或者是数据项的哈希值
非叶子节点的value根据其孩子节点的信息，然后按照Hash算法计算而得出的Merkle树原理
在比特币网络中，Merkle树是自底向上构建的。
在下图的例子中，首先将L1-L4四个单元数据哈希化，然后将哈希值存储至相应的叶子节点。这些节点是Hash0-0, Hash0-1, Hash1-0, Hash1-1
将相邻两个节点的哈希值合并成一个字符串，然后计算这个字符串的哈希，得到的就是这两个节点的父节点的哈希值。如果该层的树节点个数是单数，那么对于最后剩下的树节点，这种情况就直接对它进行哈希运算，其父节点的哈希就是其哈希值的哈希值（对于单数个叶子节点，有着不同的处理方法，也可以采用复制最后一个叶子节点凑齐偶数个叶子节点的方式）。循环重复上述计算过程，最后计算得到最后一个节点的哈希值，将该节点的哈希值作为整棵树的哈希。若两棵树的根哈希一致，则这两棵树的结构、节点的内容必然相同。
优势:
①快速重哈希
当树节点内容发生变化时，能够在前一次哈希计算的基础上，仅仅将被修改的树节点进行哈希重计算，便能得到一个新的根哈希用来代表整棵树的状态。
②轻节点扩展
采用Merkle树，可以在公链环境下扩展一种“轻节点”。轻节点的特点是对于每个区块，仅仅需要存储约80个字节大小的区块头数据，而不存储交易列表，回执列表等数据。然而通过轻节点，可以实现在非信任的公链环境中验证某一笔交易是否被收录在区块链账本的功能。这使得像比特币，以太坊这样的区块链能够运行在个人PC，智能手机等拥有小存储容量的终端上。
劣势：存储空间开销大
三、MPT的结构设计
1.节点分类
⑴空节点:空节点用来表示空串
⑵分支节点:分支节点用来表示MPT树中所有拥有超过1个孩子节点以上的非叶子节点，定义:

分支节点的孩子列表中，最后一个元素是用来存储自身的内容。每个分支节点会有一个附带的字段nodeFlag，记录了一些辅助数据：
①节点哈希：当节点变脏时，该字段被置空，若该字段不为空，则当需要进行哈希计算时，可以直接使用上次计算的结果
②脏标志：当一个节点被修改时，该标志位被置为1
③诞生标志：当该节点第一次被载入内存中（或被修改时），会被赋予一个计数值作为诞生标志，该标志会被作为节点驱除的依据，清除内存中“太老”的未被修改的节点，防止占用的内存空间过多
叶子节点和扩展节点
⑶叶子节点与扩展节点的定义相似:

①Key：用来存储属于该节点范围的key
②Val：用来存储该节点的内容
★Key是MPT树实现树高压缩的关键
当MPT试图插入一个节点，插入过程中发现目前没有与该节点Key拥有相同前缀的路径。此时MPT把剩余的Key存储在叶子或扩展节点的Key字段中，充当一个”Shortcut“。例如图中我们将红线所圈的节点称为node1, 将紫色线所圈的节点称为node2。node1与node2共享路径前缀t，但是node1在插入时，树中没有与oast有共同前缀的路径，因此node1的key为oast，实现了编码路径的压缩。
优势:
①提高节点的查找效率，避免过多的磁盘访问
②减少存储空间浪费，避免存储无用的节点
★叶子节点的Val字段存储的是一个数据项的内容
★扩展节点的Val字段存储的是其孩子节点在数据库中存储的索引值（孩子节点的哈希值）或是其孩子节点的引用；这种设计的目的是：（1）当整棵树被持久化到数据库中时，保持节点间的关联关系；（2）从数据库中读取节点时，尽量避免不必要的IO开销；在内存中，父节点与子节点之间关联关系可以通过引用、指针等编程手段实现，但是当树节点持久化到数据库，父节点中会存储一个子节点在数据库中的索引值，以此保持关联关系。同样，从数据库中读取节点时，本着最小IO开销的原则，仅需要读取那些需要用到的节点数据即可，因此若目前该节点已经包含所需要查找的信息时，便无须将其子节点再读取出来；若不包含所需信息则根据子节点的哈希索引递归读取子节点，直至读取到所需要的信息。
★在以太坊中，通过在Key中加入特殊的标志来区分叶子节点和扩展节点。

⒉key编码
MPT树的key值共有三种不同的编码方式，以满足不同场景的不同需求
⒈Raw编码
Raw编码就是原生的key值，不做任何改变。这种编码方式的key，是MPT对外提供接口的默认编码方式。
⒉Hex编码
Hex编码用于对内存中树节点key进行编码
在以太坊中，进行树操作前，首先会进行一个key编码的转换，将一个字节的高低四位内容分拆成两个字节存储。通过编码转换，key的每一位的值范围都在[0, 15]内。因此，一个分支节点的孩子至多只有16个。这种编码方式就是Hex编码。以太坊通过这种方式，减小了每个分支节点的容量，但是在一定程度上增加了树高。
从Raw编码向Hex编码的转换规则是：将Raw编码的每个字符，根据高4位低4位拆成两个字节；若该Key对应的节点存储的是真实的数据项内容（即该节点是叶子节点），则在末位添加一个ASCII值为16的字符作为终止标志符；
若该key对应的节点存储的是另外一个节点的哈希索引（即该节点是扩展节点），则不加任何字符；

⒊HP (Hex-Prefix)编码
HP编码用于对数据库中的树节点key进行编码。因为叶子和扩展节点定义是共享的，即便持久化到数据库中，存储的方式也是一致的。当节点加载到内存时，需要通过一种额外的机制来区分节点的类型。于是以太坊就提出了一种HP编码对存储在数据库中的叶子和扩展节点的key进行编码区分。在将这两类节点持久化到数据库之前，首先会对该节点的key做编码方式的转换，即从Hex编码转换成HP编码
HP编码的规则如下：
若原key的末尾字节的值为16（即该节点是叶子节点），去掉该字节；在key之前增加一个半字节，其中最低位用来编码原本key长度的奇偶信息，key长度为奇数，则该位为1；低2位中编码一个特殊的终止标记符，若该节点为叶子节点，则该位为1；
若原本key的长度为奇数，则在key之前再增加一个值为0x0的半字节；
将原本key的内容作压缩，即将两个字符以高4位低4位进行划分，存储在一个字节中（Hex扩展的逆过程）；
★三种编码方式的转换关系
Raw编码：当数据项被插入到树中时，Raw编码被转换成Hex编码；
Hex编码：当树节点被持久化到数据库时，Hex编码被转换成HP编码；
HP编码:当树节点被加载到内存时，HP编码被转换成Hex编码；

⒊安全的MPT
以上介绍的MPT树，可以用来存储内容为任何长度的key-value数据项。倘若数据项的key长度没有限制时，当树中维护的数据量较大时，仍然会造成整棵树的深度变得越来越深，会造成以下影响：
①查询一个节点可能会需要许多次IO读取，效率低下；
②系统易遭受Dos攻击，攻击者可以通过在合约中存储特定的数据，“构造”一棵拥有一条很长路径的树，然后不断地调用SLOAD指令读取该树节点的内容，造成系统执行效率极度下降；
③所有的key其实是一种明文的形式进行存储；
为了解决以上问题，在以太坊中对MPT再进行了一次封装，对数据项的key进行了一次哈希计算，因此最终作为参数传入到MPT接口的数据项其实是(SHA-3(key), value)
优势：
传入MPT接口的key是固定长度的（32字节），可以避免出现树中出现长度很长的路径；

劣势：
每次树操作需要增加一次哈希计算；
需要在数据库中存储额外的sha3(key)与key之间的对应关系；

三、MPT几种核心的基本操作
⒈Get
一次Get操作的过程为：
①将需要查找Key的Raw编码转换成Hex编码，得到的内容称之为搜索路径；
②从根节点开始搜寻与搜索路径内容一致的路径
☆若当前节点为叶子节点，存储的内容是数据项的内容，且搜索路径的内容与叶子节点的key一致，则表示找到该节点；反之则表示该节点在树中不存在。
☆若当前节点为扩展节点，且存储的内容是哈希索引，则利用哈希索引从数据库中加载该节点，再将搜索路径作为参数，对新解析出来的节点递归地调用查找函数。
☆若当前节点为扩展节点，存储的内容是另外一个节点的引用，且当前节点的key是搜索路径的前缀，则将搜索路径减去当前节点的key，将剩余的搜索路径作为参数，对其子节点递归地调用查找函数；若当前节点的key不是搜索路径的前缀，表示该节点在树中不存在。
☆若当前节点为分支节点，若搜索路径为空，则返回分支节点的存储内容；反之利用搜索路径的第一个字节选择分支节点的孩子节点，将剩余的搜索路径作为参数递归地调用查找函数。
⒉Insert
插入操作也是基于查找过程完成的，一个插入过程为：
①首先找到与新插入节点拥有最长相同路径前缀的节点，记为Node；
若该Node为分支节点且
☆剩余的搜索路径不为空，则将新节点作为一个叶子节点插入到对应的孩子列表中
☆剩余的搜索路径为空（完全匹配），则将新节点的内容存储在分支节点的第17个孩子节点项中（Value）；
若该节点为叶子或扩展节点：
☆剩余的搜索路径与当前节点的key一致，则把当前节点Val更新即可；
☆剩余的搜索路径与当前节点的key不完全一致，则将叶子或扩展节点的孩子节点替换成分支节点，将新节点与当前节点key的共同前缀作为当前节点的key，将新节点与当前节点的孩子节点作为两个孩子插入到分支节点的孩子列表中，同时当前节点转换成了一个扩展节点（若新节点与当前节点没有共同前缀，则直接用生成的分支节点替换当前节点）
若插入成功，则将被修改节点的dirty标志置为true，hash标志置空（之前的结果已经不可能用），且将节点的诞生标记更新为现在；
insert
⒊ Delete
删除操作与插入操作类似，都需要借助查找过程完成，一次删除过程为：
找到与需要插入的节点拥有最长相同路径前缀的节点，记为Node

若Node为叶子或扩展节点：
①若剩余的搜索路径与node的Key完全一致，则将整个node删除；
②若剩余的搜索路径与node的key不匹配，则表示需要删除的节点不存于树中，删除失败；
③若node的key是剩余搜索路径的前缀，则对该节点的Val做递归的删除调用；

若Node为分支节点：
①删除孩子列表中相应下标标志的节点；
②删除结束，若Node的孩子个数只剩下一个，那么将分支节点替换成一个叶子或扩展节点；

若删除成功，则将被修改节点的dirty标志置为true，hash标志置空（之前的结果已经不可能用），且将节点的诞生标记更新为现在；

3.4 Update
更新操作就是Insert与Delete的结合。当用户调用Update函数时，若value不为空，则隐式地转为调用Insert；若value为空，则隐式地转为调用Delete。
3.5 Commit
Commit函数提供将内存中的MPT数据持久化到数据库的功能。MPT快速计算所维护数据集哈希标识以快速状态回滚的功能，都是在该函数中实现的。在commit完成后，所有变脏的树节点会重新进行哈希计算，并且将新内容写入数据库；最终新的根节点哈希将被作为MPT的最新状态被返回。

四、MPT提交过程
⒈单个节点是如何进行哈希计算和存储的。
首先是对单节点进行脏位的判断，若当前节点未被修改，则直接返回该节点的哈希值，调用结束（此外，若当前节点既未被修改，同时存在于内存的时间又”过长“，则将以该节点为根节点的子树从内存中驱除），若该节点为脏节点，对该节点进行哈希重计算。首先是对当前节点的孩子节点进行哈希计算，对孩子节点的哈希计算是利用递归地对节点进行处理完成。这一步骤的目的是将孩子节点的信息各自转换成一个哈希值进行表示；。
对当前节点进行哈希计算。哈希计算利用SHA-256哈希算法对当前节点的RLP编码进行哈希计算；
对于分支节点来说，该节点的RLP编码就是对其孩子列表的内容进行编码，且在第二步中，所有的孩子节点所有已经被转换成了一个哈希值；
对于叶子和扩展节点来说，该节点的RLP编码就是对其Key，Value字段进行编码。同样在第二步中，若Value指代的是另外一个节点的引用，则已经被转换成了一个哈希值（在第二步中，Key已经被转换成了HP编码）；将当前节点的数据存入数据库，存储的格式为[节点哈希值，节点的RLP编码]。将自身的dirty标志置为false，并将计算所得的哈希值进行缓存。

⒉MPT树的提交过程
MPT树的提交过程就是以根节点为入口，对根节点进行提交调用即可。



上图展示一棵MPT被持久化的过程：
左下角的叶子节点计算得到哈希为0xaa，将其存入数据库中，并在其父节点中用哈希值进行替换；粉色的扩展节点计算得到哈希为0xcc，在父节点用中0xcc进行替换；递归至根节点，计算得到根节点的哈希为0xee，即整棵树的哈希为0xee。

★判断一个节点在内存中存在时间是否过长的依据是：
①该节点未被修改；
②当前MPT的计数器减去节点的诞生标志超过了固定的上限；
③每当MPT调用一次Commit函数，MPT的计数器发生自增；

五、MPT实现功能优化
⒈快速计算所维护数据集哈希标识
这个特点体现在单节点计算的第一步，即在节点哈希计算之前会对该节点的状态进行判断，只有当该节点的内容变脏，才会进行哈希重计算、数据库持久化等操作。如此一来，在某一次事务操作中，对整棵MPT树的部分节点的内容产生了修改，那么一次哈希重计算，仅需对这些被修改的节点、以及从这些节点到根节点路径上的节点进行重计算，便能重新获得整棵树的新哈希。

⒉快速状态回滚
在公链的环境下，采用POW算法是可能会造成分叉而导致区块链状态进行回滚的。在以太坊中，由于出块时间短，这种分叉的几率很大，区块链状态回滚的现象很频繁。

★所谓的状态回滚指的是：
（1）区块链内容发生了重组织，链头发生切换
（2）区块链的世界状态（账户信息）需要进行回滚，即对之前的操作进行撤销。

MPT树就提供了一种机制，可以当区块碰撞发生了，零延迟地完成世界状态的回滚。这种优势的代价就是需要浪费存储空MPT树就提供了一种机制，可以当区块碰撞发生了，零延迟地完成世界状态的回滚。这种优势的代价就是需要浪费存储空间去冗余地存储每个节点的历史状态。

每个节点在数据库中的存储都是值驱动的。当一个节点的内容发生了变化，其哈希相应改变，而MPT将哈希作为数据库中的索引，也就实现了对于每一个值，在数据库中都有一条确定的记录。而MPT是根据节点哈希来关联父子节点的，因此每当一个节点的内容发生变化，最终对于父节点来说，改变的只是一个哈希索引值；父节点的内容也由此改变，产生了一个新的父节点，递归地将这种影响传递到根节点。最终，一次改变对应创建了一条从被改节点到根节点的新路径，而旧节点依然可以根据旧根节点通过旧路径访问得到。所以，在以太坊中，发生分叉而进行世界状态回滚时，仅需要用旧的MPT根节点作为入口，即可完成

⒊轻节点扩展
★轻节点
在以太坊或比特币中，一个参与共识的全节点通常会维护整个区块链的数据，每个区块中的区块头信息，所有的交易，回执信息等。由于区块链的不可篡改性，这将导致随着时间的增加，整个区块链的数据体量会非常庞大。运行在个人PC或者移动终端的可能性显得微乎其微。为了解决这个问题，一种轻量级的，只存储区块头部信息的节点被提出。这种节点只需要维护链中所有的区块头信息（一个区块头的大小通常为几十个字节，普通的移动终端设备完全能够承受出）。
在公链的环境下，仅仅通过本地所维护的区块头信息，轻节点就能够证明某一笔交易是否存在与区块链中；某一个账户是否存在与区块链中，其余额是多少等功能。
★Merkle证明
Merkle证明指一个轻节点向一个全节点发起一次证明请求，询问全节点完整的默克尔树中，是否存在一个指定的节点；全节点向轻节点返回一个默克尔证明路径，由轻节点进行计算，验证存在性。
★Merkle证明过程
如有棵如下图所示的merkle树，如果某个轻节点想要验证9Dog:64这个树节点是否存在于Merkle树中，只需要向全节点发送该请求，全节点会返回一个1FXq:18, ec20,8f74的一个路径。得到路径之后，轻节点利用9Dog:64与1FXq:18求哈希，在与ec20求哈希，最后与8f74求哈希，得到的结果与本地维护的根哈希相比，是否相等。

★Merkle证明安全性
①若全节点返回的是一条恶意的路径？试图为一个不存在于区块链中的节点伪造一条合法的Merkle路径，使得最终的计算结果与区块头中的Merkle根哈希相同。
由于哈希的计算具有不可预测性，使得一个恶意的“全”节点想要为一条不存在的节点伪造一条“伪路径”使得最终计算的根哈希与轻节点所维护的根哈希相同是不可能的。

★为什么不直接向全节点请求该节点是否存在于区块链中
由于在公链的环境中，无法判断请求的全节点是否为恶意节点，因此直接向某一个或者多个全节点请求得到的结果是无法得到保证的。但是轻节点本地维护的区块头信息，是经过工作量证明验证的，也就是经过共识一定正确的，若利用全节点提供的Merkle路径，与代验证的节点进行哈希计算，若最终结果与本地维护的区块头中根哈希一致，则能够证明该节点一定存在于Merkle树中。
⒈简单支付验证
在以太坊中，利用Merkle证明在轻节点中实现简单支付验证，即在无需维护具体交易信息的前提下，证明某一笔交易是否存在于区块链中。
